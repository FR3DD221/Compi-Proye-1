package proye1_compi;
import java_cup.runtime.*;

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;

    @SuppressWarnings("deprecation")
    public Parser(Lexer lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }
:}

/* define how to connect to the scanner! */
//init with {: s.init(); :};
//scan with {: return s.next_token(); :};
init with {::};
scan with {:return lex.next_token();:};


/* Terminales (tokens returned by the scanner). */
terminal            IDENTIFIER, SEMI, PLUS, MINUS, MINUSW, TIMES, UMINUS, PRODUCT, DIVISION, MINPLS, POWER, MODULUS, LPAREN, RPAREN, INTEGER_LITERAL;
terminal Integer    NUMBER;        // our scanner provides numbers as integers
terminal            DELIMETERBLOCK, ASIGNINTSARRAY, ASIGNCHARSARRAY, INT, CHAR, FLOAT, BOOL, STRINGT, FUNC, MAIN, PARAM, COMA, STRING_LITERAL, EQEQ, BREAK, BOOLEAN, ABSTRACT, EQ, DOT;
terminal            DIFF, NEGATION, GRATHER, GRATHERT, LOWER, LOWERT, COMPARATION, AND, OR, SEP;
terminal            FLOATNUM;
terminal            TRUE, FALSE;
terminal            IF, ELSE, WHILE, FOR, IN, RANGE, SWITCH, CASE, ARRAY;
terminal            LOC, GLOB, BRAKE, DEFAULT, RETURN, PRINT, INPUT;
terminal            PARENTS, PARENTC, SQUARES, SQUAREC;
terminal            ENDEXPR;

/* No terminales */
non terminal            expr_list;
non terminal            Integer expr;// used to store evaluated subexpressions
non terminal            SI, varIns, varAsig, BLOCK, compAritOp, factor, term, funcStruc, mainStruc, types;
non terminal            ifStruc, ifElseStruc, whileStruc, arrayIns, arrayAsig, arrayInsAsign, elementos, switchStruc, caseStruc;
non terminal            exprP, exprLog, exprUni, opRel, opLog, arrayElement;

/* Orden de precedencia */
precedence left MINPLS, PLUS, MINUSW;
precedence left PRODUCT;
precedence left DIVISION;

/* The grammar rules */    

start with SI;

SI ::= BLOCK;

//Los distintos tipos que pueden tener una funcion o variable

//Bloque que se usa para el codigo siga un rumbo, vease como la lista de posibles expresiones
BLOCK  ::=  BLOCK exprP ENDEXPR
       | BLOCK varAsig 
       | BLOCK mainStruc
       | BLOCK funcStruc 
       | BLOCK varIns 
       | BLOCK ifStruc 
       | BLOCK ifElseStruc 
       | BLOCK whileStruc 
       | BLOCK switchStruc 
       | BLOCK arrayIns ENDEXPR
       | BLOCK arrayInsAsign ENDEXPR
       | exprP ENDEXPR
       | arrayIns ENDEXPR
       | arrayInsAsign ENDEXPR
       | mainStruc 
       | funcStruc 
       | varAsig    
       | varIns 
       | ifStruc 
       | ifElseStruc
       | switchStruc
       //| for
       | whileStruc;


        


//Operaciones aritmeticas simples entre dos numeros
/* Reglas de producción para operaciones aritméticas */
compAritOp ::= term
             | compAritOp MINPLS term  {: System.out.println("Se hizo MULTIPLESIMB"); :}
             | compAritOp PLUS term   {: System.out.println("Se hizo SUMA"); :}
             | compAritOp MINUSW term  {: System.out.println("Se hizo RESTA"); :};

term       ::= factor
             | term PRODUCT factor  {: System.out.println("Se hizo PRODUCTO"); :}
             | term DIVISION factor {: System.out.println("Se hizo COCIENTE"); :};

factor     ::= INTEGER_LITERAL
             | FLOATNUM
             | STRING_LITERAL
             | IDENTIFIER
             | arrayElement
             | PARENTS compAritOp PARENTC;  


//Manejo de distintas expresiones de comparacion y union
exprP ::= exprLog 
      | compAritOp        
      | exprUni;

exprLog ::= compAritOp opRel compAritOp
        | PARENTS exprLog PARENTC
        | MINUSW compAritOp 
        | PLUS compAritOp 
        | MINPLS compAritOp 
        | TRUE
        | FALSE;

exprUni ::= exprLog opLog exprP       {: System.out.println("Se hizo 1"); :}
        | IDENTIFIER opLog exprP                   {: System.out.println("Se hizo 2"); :}
        | PARENTS exprUni PARENTC    {: System.out.println("Se hizo 3"); :};

opRel ::= GRATHER | GRATHERT | LOWER | LOWERT | DIFF | COMPARATION;
opLog ::= AND | OR;



//Asignación de un valor a una variable
varAsig      ::=
             IDENTIFIER EQ exprP ENDEXPR       {:System.out.println("Se asigno VAR");:};
        

//Instanciacion simple de variables
varIns       ::= LOC SEP INT SEP IDENTIFIER ENDEXPR       {:System.out.println("Se creo variable local");:}
             | LOC SEP CHAR SEP IDENTIFIER ENDEXPR       {:System.out.println("Se creo variable local");:}
             | LOC SEP FLOAT SEP IDENTIFIER ENDEXPR       {:System.out.println("Se creo variable local");:}
             | LOC SEP BOOL SEP IDENTIFIER ENDEXPR       {:System.out.println("Se creo variable local");:}
             | GLOB SEP INT SEP IDENTIFIER ENDEXPR        {:System.out.println("Se creo variable global");:}
             | GLOB SEP CHAR SEP IDENTIFIER ENDEXPR        {:System.out.println("Se creo variable global");:}
             | GLOB SEP FLOAT SEP IDENTIFIER ENDEXPR        {:System.out.println("Se creo variable global");:}
             | GLOB SEP BOOL SEP IDENTIFIER ENDEXPR        {:System.out.println("Se creo variable global");:};

//Declaracion inicial del bloque para las funciones
funcStruc    ::= FUNC SEP INT SEP IDENTIFIER DELIMETERBLOCK BLOCK DELIMETERBLOCK  {:System.out.println("Se declaro funcion normal");:}
             | FUNC SEP CHAR SEP IDENTIFIER DELIMETERBLOCK BLOCK DELIMETERBLOCK   {:System.out.println("Se declaro funcion normal");:}
             | FUNC SEP BOOL SEP IDENTIFIER DELIMETERBLOCK BLOCK DELIMETERBLOCK   {:System.out.println("Se declaro funcion normal");:}
             | FUNC SEP FLOAT SEP IDENTIFIER DELIMETERBLOCK BLOCK DELIMETERBLOCK  {:System.out.println("Se declaro funcion normal");:}; 

mainStruc    ::= FUNC SEP INT SEP MAIN DELIMETERBLOCK BLOCK DELIMETERBLOCK  {:System.out.println("Se declaro funcion MAIN  ");:}; 


ifStruc      ::= IF PARENTS exprP PARENTC DELIMETERBLOCK BLOCK DELIMETERBLOCK   {:System.out.println("Se declaro estructura condicional IF");:};
ifElseStruc  ::= ifStruc ELSE DELIMETERBLOCK BLOCK DELIMETERBLOCK;

//Produccion while
whileStruc   ::= WHILE PARENTS exprP PARENTC DELIMETERBLOCK BLOCK DELIMETERBLOCK   {:System.out.println("Se declaro el ciclo while");:};


//Declaracion, asignacion y acceso a un array
arrayIns ::=  LOC SEP INT SEP ARRAY SEP IDENTIFIER SQUARES INTEGER_LITERAL SQUAREC
            | LOC SEP CHAR SEP ARRAY SEP IDENTIFIER SQUARES INTEGER_LITERAL SQUAREC
            | GLOB SEP INT SEP ARRAY SEP IDENTIFIER SQUARES INTEGER_LITERAL SQUAREC
            | GLOB SEP CHAR SEP ARRAY SEP IDENTIFIER SQUARES INTEGER_LITERAL SQUAREC;

arrayAsig ::= EQ SQUARES elementos SQUAREC;

elementos ::= compAritOp COMA elementos| compAritOp;

arrayInsAsign ::= arrayIns arrayAsig;

arrayElement ::= IDENTIFIER SQUARES INTEGER_LITERAL SQUAREC;


//Declaracion de switch
switchStruc ::= SWITCH PARENTS IDENTIFIER PARENTC DELIMETERBLOCK caseStruc DEFAULT SEP BLOCK DELIMETERBLOCK {:System.out.println("Se declaro estructura switch");:};
caseStruc ::= CASE SEP compAritOp SEP BLOCK BREAK ENDEXPR caseStruc
          | CASE SEP compAritOp SEP BLOCK BREAK ENDEXPR;

/*
//Declaracion del for
for ::= FOR PARENTS types IDENTIFIER EQ exprP SEP IDENTIFIER opRel exprP SEP IDENTIFIER unaryOp PARENTC DELIMITERBLOCK BLOCK DELIMITERBLOCK {:System.out.println("Se declaro ciclo for");:};
*/       

